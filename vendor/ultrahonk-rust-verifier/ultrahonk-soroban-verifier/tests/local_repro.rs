use soroban_sdk::{Bytes, Env};
use std::fs;
use ultrahonk_soroban_verifier::field::Fr;
use ultrahonk_soroban_verifier::transcript::generate_transcript;
use ultrahonk_soroban_verifier::utils::{load_proof, load_vk_from_bytes};
use ultrahonk_soroban_verifier::UltraHonkVerifier;

fn hex_to_bytes(hex: &str) -> Vec<u8> {
    let s = hex.trim();
    assert!(s.len() % 2 == 0, "hex length must be even");
    let mut out = Vec::with_capacity(s.len() / 2);
    for i in (0..s.len()).step_by(2) {
        out.push(u8::from_str_radix(&s[i..i + 2], 16).expect("invalid hex"));
    }
    out
}

const BARY_BYTES: [[u8; 32]; 8] = [
    [
        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58,
        0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xef, 0xff,
        0xec, 0x51,
    ],
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0xd0,
    ],
    [
        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58,
        0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xef, 0xff,
        0xff, 0x11,
    ],
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x90,
    ],
    [
        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58,
        0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xef, 0xff,
        0xff, 0x71,
    ],
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xf0,
    ],
    [
        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81, 0x81, 0x58,
        0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xef, 0xff,
        0xfd, 0x31,
    ],
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x13, 0xb0,
    ],
];

fn compute_next_target_sum(
    round_univariate: &[Fr],
    round_challenge: Fr,
) -> Result<Fr, &'static str> {
    let mut b_poly = Fr::one();
    for i in 0..8 {
        b_poly = b_poly * (round_challenge - Fr::from_u64(i as u64));
    }

    let mut acc = Fr::zero();
    for i in 0..8 {
        let bary_val = Fr::from_bytes(&BARY_BYTES[i]);
        let denom = bary_val * (round_challenge - Fr::from_u64(i as u64));
        let inv = denom.inverse().ok_or("denom zero")?;
        acc = acc + (round_univariate[i] * inv);
    }

    Ok(b_poly * acc)
}

#[test]
fn reproduce_deal_verification_failure_details() {
    let env = Env::default();
    env.cost_estimate().budget().reset_unlimited();

    let vk_raw =
        fs::read("../../../circuits/deal_valid/target/vk.compact").expect("read vk.compact");
    let proof_hex = fs::read_to_string("/tmp/deal_proof.hex").expect("read /tmp/deal_proof.hex");
    let pi_hex = fs::read_to_string("/tmp/deal_pi.hex").expect("read /tmp/deal_pi.hex");

    let proof_raw = hex_to_bytes(&proof_hex);
    let pi_raw = hex_to_bytes(&pi_hex);

    let vk = Bytes::from_slice(&env, &vk_raw);
    let proof = Bytes::from_slice(&env, &proof_raw);
    let pi = Bytes::from_slice(&env, &pi_raw);

    let parsed = load_proof(&proof);
    let vk_parsed = load_vk_from_bytes(&vk).expect("vk parse");
    let transcript = generate_transcript(&env, &parsed, &pi, &vk_parsed);

    let mut round_target = Fr::zero();
    for round in 0..(vk_parsed.log_circuit_size as usize) {
        let ru = &parsed.sumcheck_univariates[round];
        let check = ru[0] + ru[1];
        if check != round_target {
            println!("sumcheck round failed at round {}", round);
            println!(
                "expected target = 0x{}",
                hex::encode(round_target.to_bytes())
            );
            println!("actual sum = 0x{}", hex::encode(check.to_bytes()));
            break;
        }
        round_target =
            compute_next_target_sum(ru, transcript.sumcheck_u_challenges[round]).unwrap();
    }

    let verifier = UltraHonkVerifier::new(&env, &vk).expect("vk parse");
    let result = verifier.verify(&proof, &pi);
    println!("verify result: {:?}", result);
    assert!(
        result.is_ok(),
        "expected successful verification for current payload"
    );
}
