# Difficulties: ZK + MPC on Stellar

Issues we (Codex, Claude, and I) ran into building an onchain poker game with MPC secret sharing and UltraHonk ZK proofs with Soroban.

## 1. Transcript protocol mismatch between co-noir and the Soroban verifier

This was the biggest issue. co-noir (TACEO co-snarks) and the Soroban UltraHonk verifier use different Fiat-Shamir transcript protocols, so proofs generated by one can't be verified by the other.

The co-noir prover pre-hashes the entire VK into a single `vk_hash` field element and encodes G1 points as raw (x, y) field elements. The Soroban verifier hashes VK header fields individually and encodes G1 points as 4 limbs (x_lo, x_hi, y_lo, y_hi). This produces completely different challenges, so every proof submission failed with `Error(Contract, #7)` even though co-noir's own Rust verifier accepted the same proof.

On top of the transcript mismatch, the verifier expected a different VK format (3680 bytes limb-encoded vs 1824 bytes compact), a different proof field count (456 vs 457), and a different entity count (40 vs 41 — the extra being `Q_POSEIDON2_INTERNAL` from newer UltraHonk). Each of these caused its own failure and needed separate fixes: a Python conversion script for VKs, updated constants, and updated entity ordering.

I ended up rewriting the Soroban verifier's `transcript.rs` (~50 lines) to match co-noir's protocol, while leaving the core verification math (sumcheck, shplemini, pairing) untouched.

Also - I don't think the latest Ultrahonk verifier is compatible with the latest Noir, but wouldn't be difficult to update.

## 2. Soroban resource budgeting for ZK verification

Soroban contracts have CPU instruction limits, and UltraHonk verification involves heavy elliptic curve operations (multi-scalar multiplications, pairings). Resource behavior is sensitive to CLI flags and simulation outcomes — simulation can pass while actual submission fails with `ResourceLimitExceeded`. Costs also vary across `commit_deal`, `reveal_board`, and `submit_showdown` because proof and public-input sizes differ by circuit. The coordinator needed retry logic with increasing `--instruction-leeway` rather than a single fixed budget.

## 3. Stellar CLI ergonomics for complex arguments

Passing proof data to Soroban contracts via `stellar contract invoke` is awkward. Proof data (14+ KB hex-encoded), public inputs (arrays of 32-byte hex values), and nested structs all go through as CLI arguments. Enum encoding is also fragile — payload variants need object JSON with string-encoded i128 (e.g., `{"Bet":"20"}`), and vector-style encodings panic in `soroban-spec-tools`.

## 4. No established ZK tooling for Stellar

Unlike Ethereum (which has Solidity verifiers, circom/snarkjs, and established patterns), Stellar/Soroban has no ZK verification ecosystem. The Soroban verifier here was an independent port of Barretenberg's verifier with no community maintenance or version tracking. Keeping up with prover changes is entirely manual.

## 5. Wallet integration issues (Freighter browser API)

Freighter integration was consistently painful. Different builds expose different globals (`window.freighterApi` vs the `@stellar/freighter-api` messaging bridge), and extension injection can be delayed after page load, causing false "wallet not found" errors.

Modern Freighter `signMessage` follows SEP-53 semantics (signing over `SHA256("Stellar Signed Message:\n" + message)`) rather than raw bytes, so API auth signatures that were valid under SEP-53 got rejected by the coordinator's raw-byte verification. Even after adding SEP-53 support, some Freighter builds return signature payloads that don't normalize cleanly to 64-byte Ed25519 signatures, causing persistent 401s in local dev.

On top of that, `signMessage` for API auth and `signTransaction` for on-chain `require_auth` are completely separate concerns — passing API auth doesn't mean on-chain actions will work.

Ended up adding an `ALLOW_INSECURE_DEV_AUTH=1` bypass for local iteration.

## 6. Stellar wallet kit on mobile

Stellar wallet kit was flakey on mobile. It would randomly disconnect, halt mid-signing on transactions, and sometimes not detect any installed wallets at all. Made mobile testing pretty unreliable and I ended up only developing for browser. Seems like this was just me though.

## 7. RPC latency

Spent a while debugging what turned out to be RPC latency. Onchain operations were executing before previous transactions had actually settled, causing failures that looked like contract logic bugs. Switching away from the default RPC endpoint improved things, but it took a while to identify latency as the root cause rather than something wrong with the contract code.

## 9. ZK verifier rejection can deadlock the table

When `submit_showdown` fails onchain (e.g., verifier `Error(Contract, #7)`), the hand stays in `Showdown` and can't progress. Without a fallback the frontend loops on retries, the coordinator and onchain state diverge, and the table looks permanently stuck to players. Added a timeout-claim fallback (`claim_timeout`) so the table can move to settlement and keep going.

## 10. Deal commitment count must match seated players

`commit_deal` enforces `hand_commitments.len() == table.players.len()`. With pre-seeded onchain seats, generating a deal proof for only the currently joined wallets fails with `WrongCommitmentCount`. Deal proof generation has to account for all N onchain seats, using deterministic placeholders for unclaimed ones.

## 11. Browser wallet join UX vs `require_auth` in local dev

`join_table` requires `player.require_auth()` and a token transfer from that player. In local coordinator-driven flows, browser wallets are often not the same as pre-seeded local identities, and the coordinator can't join arbitrary wallets without their signing authority. Worked around this with pre-seeded onchain seats plus a coordinator-side wallet-to-seat lobby mapping.

## 12. Auto-betting vulnerable to transient transport errors

The coordinator auto-submits `player_action` (check/call) to advance betting phases. These calls occasionally failed with transient RPC errors like `connection reset by peer`, breaking hand progression. Needed retry logic on these paths too.

## 13. "Not enough funds" with local-only wallet

During local development, the browser wallet showed "not enough funds" errors when trying to interact with the contract. The wallet was funded on the local standalone network but the error message was confusing — transactions could still be signed and submitted successfully, but the misleading insufficient-funds warning took a while to diagnose. The issue was simply that the wallet only had local network funds and the wallet UI was checking balances against testnet/pubnet, but it didn't block actual transaction signing on the local network.
